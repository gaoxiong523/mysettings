<application>
  <component name="AppStorage">
    <histories>
      <item value="* If you would like to use a {@code Future} for the sake * of cancellability but not provide a usable result, you can * declare types of the form {@code Future&lt;?&gt;} and * return {@code null} as a result of the underlying task." />
      <item value="Cancellation is performed by the * {@code cancel} method. Additional methods are provided to * determine if the task completed normally or was cancelled. Once a * computation has completed, the computation cannot be cancelled." />
      <item value="The result can only be retrieved using method * {@code get} when the computation has completed, blocking if * necessary until it is ready." />
      <item value="Methods are provided to check if the computation is * complete, to wait for its completion, and to retrieve the result of * the computation." />
      <item value="A {@code Future} represents the result of an asynchronous * computation." />
      <item value="A task that returns a result and may throw an exception. * Implementors define a single method with no arguments called" />
      <item value="PRESENT" />
      <item value="More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;." />
      <item value="Adds the specified element to this set if it is not already present." />
      <item value="Unable to commit against JDBC Connection" />
      <item value="ramp-up" />
      <item value="ram" />
      <item value="Shutdown hook installed for: NFLoadBalancer-PingTimer-order-service" />
      <item value="Allocation Failure" />
      <item value="Allocation" />
      <item value="codec" />
      <item value="Resource Manager Inbound" />
      <item value="剩余" />
      <item value="debit" />
      <item value="deduct" />
      <item value="commodity Code" />
      <item value="Purchase" />
      <item value="附加" />
      <item value="volatile" />
      <item value="effective" />
      <item value="This class * does not &amp;quot;understand&amp;quot; these differences except in the * mechanical sense that when a shared mode acquire succeeds, the next * waiting thread (if one exists) must also determine whether it can * acquire as well" />
      <item value="Shared mode * acquires by multiple threads may (but need not) succeed" />
      <item value="This class supports either or both a default &lt;em&gt;exclusive&lt;/em&gt; * mode and a &lt;em&gt;shared&lt;/em&gt; mode. When acquired in exclusive mode, * attempted acquires by other threads cannot succeed." />
      <item value="Subclasses should be defined as non-public internal helper * classes that are used to implement the synchronization properties * of their enclosing class" />
      <item value="Subclasses can maintain * other state fields, but only the atomically updated {@code int} * value manipulated using methods {@link #getState}, {@link * #setState} and {@link #compareAndSetState} is tracked with respect * to synchronization." />
      <item value="Given these, the other methods in this class carry * out all queuing and blocking mechanics." />
      <item value="mechanics" />
      <item value="Subclasses * must define the protected methods that change this state, and which * define what that state means in terms of this object being acquired * or released." />
      <item value="This class is designed to * be a useful basis for most kinds of synchronizers that rely on a * single atomic {@code int} value to represent state." />
      <item value="represent" />
      <item value="rely" />
      <item value="Provides a framework for implementing blocking locks and related * synchronizers (semaphores, events, etc) that rely on * first-in-first-out (FIFO) wait queues." />
      <item value="A synchronizer that may be exclusively owned by a thread. This * class provides a basis for creating locks and related synchronizers * that may entail a notion of ownership. The * {@code AbstractOwnableSynchronizer} class itself does not manage or * use this information. However, subclasses and tools may use * appropriately maintained values to help control and monitor access * and provide diagnostics." />
      <item value="exclusively" />
      <item value="Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a {@code volatile} read * and write." />
      <item value="The {@link java.util.concurrent.ArrayBlockingQueue} class provides * this functionality, so there is no reason to implement this * sample usage class.)" />
      <item value="obtain" />
      <item value="{@code Condition} factors out the {@code Object} monitor * methods ({@link Object#wait() wait}, {@link Object#notify notify} * and {@link Object#notifyAll notifyAll}) into distinct objects to * give the effect of having multiple wait-sets per object, by * combining them with the use of arbitrary {@link Lock} implementations. * Where a {@code Lock} replaces the use of {@code synchronized} methods * and statements, a {@code Condition} replaces the use of the Object * monitor methods." />
      <item value="Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one." />
      <item value="Convenience method to interrupt current thread. */" />
      <item value="Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire." />
      <item value="Creates and enqueues node for current thread and given mode. *" />
      <item value="self Interrupt" />
      <item value="Acquires in exclusive mode, aborting if interrupted. * Implemented by first checking interrupt status, then invoking * at least once {@link #tryAcquire}, returning on * success. Otherwise the thread is queued, possibly repeatedly * blocking and unblocking, invoking {@link #tryAcquire} * until success or the thread is interrupted. This method can be * used to implement method {@link Lock#lockInterruptibly}." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="573" />
        <entry key="ENGLISH" value="626" />
        <entry key="FRENCH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
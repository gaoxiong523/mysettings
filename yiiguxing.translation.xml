<application>
  <component name="AppStorage">
    <histories>
      <item value="custom init-method definition" />
      <item value="Initializing Bean" />
      <item value="methods of BeanPostProcessors" />
      <item value="Servlet Context Aware" />
      <item value="Application Context Aware" />
      <item value="Message Source Aware" />
      <item value="Application Event Publisher Aware" />
      <item value="Resource Loader Aware" />
      <item value="Embedded Value Resolver Aware" />
      <item value="Environment Aware" />
      <item value="Bean Name Aware's" />
      <item value="Aware" />
      <item value="Bean Class Loader Aware" />
      <item value="Bean Name Aware" />
      <item value="&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:" />
      <item value="In contrast to the methods in {@link ListableBeanFactory}, all of the * operations in this interface will also check parent factories if this is a * {@link HierarchicalBeanFactory}. If a bean is not found in this factory instance, * the immediate parent factory will be asked. Beans in this factory instance * are supposed to override beans of the same name in any parent factory." />
      <item value="Hierarchical" />
      <item value="There are no * constraints on how the definitions could be stored: LDAP, RDBMS, XML, * properties file, etc. Implementations are encouraged to support references * amongst beans (Dependency Injection)." />
      <item value="However, an implementation could simply return * Java objects it creates as necessary directly in Java code." />
      <item value="However" />
      <item value="Normally a BeanFactory will load bean definitions stored in a configuration * source (such as an XML document), and use the {@code org.springframework.beans} * package to configure the beans." />
      <item value="Spring's Dependency Injection functionality is * implemented using this BeanFactory interface and its subinterfaces." />
      <item value="subinterfaces" />
      <item value="&gt;Note that it is generally better to rely on Dependency Injection * (&quot;push&quot; configuration) to configure application objects through setters * or constructors, rather than use any form of &quot;pull&quot; configuration like a * BeanFactory lookup." />
      <item value="approach" />
      <item value="See chapters 4 and 11 of &quot;Expert One-on-One J2EE Design and * Development&quot; for a discussion of the benefits of this approach." />
      <item value="The point of this approach is that the BeanFactory is a central registry * of application components, and centralizes configuration of application * components (no more do individual objects need to read properties files, * for example)" />
      <item value="Since Spring * 2.0, further scopes are available depending on the concrete application * context (e.g. &quot;request&quot; and &quot;session&quot; scopes in a web environment)." />
      <item value="Which type of instance will be returned * depends on the bean factory configuration: the API is the same." />
      <item value="Depending on the bean definition, * the factory will return either an independent instance of a contained object * (the Prototype design pattern), or a single shared instance (a superior * alternative to the Singleton design pattern, in which the instance is a * singleton in the scope of the factory)." />
      <item value="This interface is implemented by objects that hold a number of bean definitions, * each uniquely identified by a String name." />
      <item value="* The root interface for accessing a Spring bean container. * This is the basic client view of a bean container; * further interfaces such as {@link ListableBeanFactory} and * {@link org.springframework.beans.factory.config.ConfigurableBeanFactory} * are available for specific purposes. *" />
      <item value="accessing" />
      <item value="Interface to be implemented by beans that want to be aware of their * bean name in a bean factory. Note that it is not usually recommended * that an object depends on its bean name, as this represents a potentially * brittle dependence on external configuration, as well as a possibly * unnecessary dependence on a Spring API." />
      <item value="For a list of all bean lifecycle methods," />
      <item value="Note that most beans will choose to receive references * to collaborating beans via corresponding bean properties or constructor * arguments (Dependency Injection)." />
      <item value="For example, beans can look up collaborating beans via the factory * (Dependency Lookup)" />
      <item value="Interface to be implemented by beans that wish to be aware of their * owning {@link BeanFactory}." />
      <item value="This implementation spares its clients from the unspecified, generally * chaotic ordering provided by {@link HashSet}, without incurring the * increased cost associated with {@link TreeSet}. It can be used to * produce a copy of a set that has the same order as the original, regardless * of the original set's implementation: * &lt;pre&gt; * void foo(Set s) { * Set copy = new LinkedHashSet(s); * ... * } * &lt;/pre&gt;" />
      <item value="&lt;p&gt;Hash table and linked list implementation of the &lt;tt&gt;Set&lt;/tt&gt; interface, * with predictable iteration order. This implementation differs from * &lt;tt&gt;HashSet&lt;/tt&gt; in that it maintains a doubly-linked list running through * all of its entries. This linked list defines the iteration ordering, * which is the order in which elements were inserted into the set * (&lt;i&gt;insertion-order&lt;/i&gt;). Note that insertion order is &lt;i&gt;not&lt;/i&gt; affected * if an element is &lt;i&gt;re-inserted&lt;/i&gt; into the set. (An element &lt;tt&gt;e&lt;/tt&gt; * is reinserted into a set &lt;tt&gt;s&lt;/tt&gt; if &lt;tt&gt;s.add(e)&lt;/tt&gt; is invoked when * &lt;tt&gt;s.contains(e)&lt;/tt&gt; would return &lt;tt&gt;true&lt;/tt&gt; immediately prior to * the invocation.)" />
      <item value="prior" />
      <item value="predictable" />
      <item value="A special {@link #LinkedHashMap(int,float,boolean) constructor} is * provided to create a linked hash map whose order of iteration is the order * in which its entries were last accessed, from least-recently accessed to * most-recently (&lt;i&gt;access-order&lt;/i&gt;). This kind of map is well-suited to * building LRU caches. Invoking the {@code put}, {@code putIfAbsent}, * {@code get}, {@code getOrDefault}, {@code compute}, {@code computeIfAbsent}, * {@code computeIfPresent}, or {@code merge} methods results * in an access to the corresponding entry (assuming it exists after the * invocation completes). The {@code replace} methods only result in an access * of the entry if the value is replaced. The {@code putAll} method generates one * entry access for each mapping in the specified map, in the order that * key-value mappings are provided by the specified map's entry set iterator. * &lt;i&gt;No other methods generate entry accesses.&lt;/i&gt; In particular, operations * on collection-views do &lt;i&gt;not&lt;/i&gt; affect the order of iteration of the * backing map." />
      <item value="accessed" />
      <item value="This technique is particularly useful if a module takes a map on input, * copies it, and later returns results whose order is determined by that of * the copy. (Clients generally appreciate having things returned in the same * order they were presented.) *" />
      <item value="This implementation spares its clients from the unspecified, generally * chaotic ordering provided by {@link HashMap} (and {@link Hashtable}), * without incurring the increased cost associated with {@link TreeMap}. It * can be used to produce a copy of a map that has the same order as the * original," />
      <item value="&lt;p&gt;Hash table and linked list implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface, * with predictable iteration order. This implementation differs from * &lt;tt&gt;HashMap&lt;/tt&gt; in that it maintains a doubly-linked list running through * all of its entries. This linked list defines the iteration ordering, * which is normally the order in which keys were inserted into the map * (&lt;i&gt;insertion-order&lt;/i&gt;). Note that insertion order is not affected * if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map. (A key &lt;tt&gt;k&lt;/tt&gt; is * reinserted into a map &lt;tt&gt;m&lt;/tt&gt; if &lt;tt&gt;m.put(k, v)&lt;/tt&gt; is invoked when * &lt;tt&gt;m.containsKey(k)&lt;/tt&gt; would return &lt;tt&gt;true&lt;/tt&gt; immediately prior to * the invocation.)" />
      <item value="quota" />
      <item value="policy" />
      <item value="While this may seem a more roundabout way to perform an aggregation * compared to simply mutating a running total in a loop, reduction * operations parallelize more gracefully, without needing additional * synchronization and with greatly reduced risk of data races." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="513" />
        <entry key="ENGLISH" value="564" />
        <entry key="FRENCH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
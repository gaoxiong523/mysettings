<application>
  <component name="AppStorage">
    <histories>
      <item value="enroll" />
      <item value="倒序" />
      <item value="顺序" />
      <item value="azkaban" />
      <item value="azkanban" />
      <item value="hive" />
      <item value="oozie" />
      <item value="This class implements the Dual-Pivot Quicksort algorithm by * Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm * offers O(n log(n)) performance on many data sets that cause other * quicksorts to degrade to quadratic performance, and is typically * faster than traditional (one-pivot) Quicksort implementations. * * All exposed methods are package-private, designed to be invoked * from public methods (in class Arrays) after performing any * necessary array bounds checks and expanding parameters into the * required forms." />
      <item value="Searches the specified array of longs for the specified value using the * binary search algorithm. The array must be sorted (as * by the {@link #sort(long[])} method) prior to making this call. If it * is not sorted, the results are undefined. If the array contains * multiple elements with the specified value, there is no guarantee which * one will be found." />
      <item value="归并排序" />
      <item value="快速排序" />
      <item value="插入排序" />
      <item value="插入" />
      <item value="冒泡" />
      <item value="Central interface to provide configuration for an application. * This is read-only while the application is running, but may be * reloaded if the implementation supports this." />
      <item value="This interface represents a naming context, which * consists of a set of name-to-object bindings. * It contains methods for examining and updating these bindings." />
      <item value="Contains methods for registering/deregistering listeners to be notified of * events fired when objects named in a context changes." />
      <item value="ass" />
      <item value="* &lt;p&gt;A min-max priority queue can be configured with a maximum size. If so, * each time the size of the queue exceeds that value, the queue automatically * removes its greatest element according to its comparator (which might be the * element that was just added). This is different from conventional bounded * queues, which either block or reject new elements when full. *" />
      <item value="* &lt;p&gt;As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its * head element -- the implicit target of the methods {@link #peek()}, {@link * #poll()} and {@link #remove()} -- is defined as the &lt;i&gt;least&lt;/i&gt; element in * the queue according to the queue's comparator. But unlike a regular priority * queue, the methods {@link #peekLast}, {@link #pollLast} and * {@link #removeLast} are also provided, to act on the &lt;i&gt;greatest&lt;/i&gt; element * in the queue instead." />
      <item value="A double-ended priority queue, which provides constant-time access to both * its least element and its greatest element, as determined by the queue's * specified comparator. If no comparator is given at construction time, the * natural order of elements is used." />
      <item value="* An unbounded priority {@linkplain Queue queue} based on a priority heap. * The elements of the priority queue are ordered according to their * {@linkplain Comparable natural ordering}, or by a {@link Comparator} * provided at queue construction time, depending on which constructor is * used. A priority queue does not permit {@code null} elements. * A priority queue relying on natural ordering also does not permit * insertion of non-comparable objects (doing so may result in * {@code ClassCastException}). *" />
      <item value="* &lt;p&gt;The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element * with respect to the specified ordering. If multiple elements are * tied for least value, the head is one of those elements -- ties are * broken arbitrarily. The queue retrieval operations {@code poll}, * {@code remove}, {@code peek}, and {@code element} access the * element at the head of the queue." />
      <item value="&lt;p&gt;A priority queue is unbounded, but has an internal * &lt;i&gt;capacity&lt;/i&gt; governing the size of an array used to store the * elements on the queue. It is always at least as large as the queue * size. As elements are added to a priority queue, its capacity * grows automatically. The details of the growth policy are not * specified." />
      <item value="&lt;p&gt;This class and its iterator implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link * Iterator} interfaces. The Iterator provided in method {@link * #iterator()} is &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of * the priority queue in any particular order. If you need ordered * traversal, consider using {@code Arrays.sort(pq.toArray())}. *" />
      <item value="A priority queue relying on natural ordering also does not permit * insertion of non-comparable objects (doing so may result in * {@code ClassCastException})." />
      <item value="An unbounded priority {@linkplain Queue queue} based on a priority heap." />
      <item value="priority" />
      <item value="unbounded" />
      <item value="The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a {@code FunctionalInterface} * annotation is present on the interface declaration." />
      <item value="&gt;If a type is annotated with this annotation type, compilers are * required to generate an error message unless:" />
      <item value="p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references." />
      <item value="Since {@linkplain java.lang.reflect.Method#isDefault() * default methods} have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of {@code java.lang.Object}, that also does * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from {@code java.lang.Object} or elsewhere." />
      <item value="Conceptually, a functional interface has exactly one abstract * method." />
      <item value="An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as * defined by the Java Language Specification." />
      <item value="&lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a linked list concurrently, and at least * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more elements; merely setting the value of * an element is not a structural modification.) This is typically * accomplished by synchronizing on some object that naturally * encapsulates the list." />
      <item value="&lt;p&gt;All of the operations perform as could be expected for a doubly-linked * list. Operations that index into the list will traverse the list from * the beginning or the end, whichever is closer to the specified index." />
      <item value="Doubly-linked list implementation of the {@code List} and {@code Deque} * interfaces. Implements all optional list operations, and permits all * elements (including {@code null}). *" />
      <item value="A collection designed for holding elements prior to processing. * Besides basic {@link java.util.Collection Collection} operations, * queues provide additional insertion, extraction, and inspection * operations. Each of these methods exists in two forms: one throws * an exception if the operation fails, the other returns a special * value (either {@code null} or {@code false}, depending on the * operation). The latter form of the insert operation is designed * specifically for use with capacity-restricted {@code Queue} * implementations; in most implementations, insert operations cannot * fail." />
      <item value="A linear collection that supports element insertion and removal at * both ends. The name &lt;i&gt;deque&lt;/i&gt; is short for &quot;double ended queue&quot; * and is usually pronounced &quot;deck&quot;. Most {@code Deque} * implementations place no fixed limits on the number of elements * they may contain, but this interface supports capacity-restricted * deques as well as those with no fixed size limit." />
      <item value="linear" />
      <item value=" bracket" />
      <item value="括号" />
      <item value="The &lt;code&gt;Stack&lt;/code&gt; class represents a last-in-first-out * (LIFO) stack of objects. It extends class &lt;tt&gt;Vector&lt;/tt&gt; with five * operations that allow a vector to be treated as a stack. The usual * &lt;tt&gt;push&lt;/tt&gt; and &lt;tt&gt;pop&lt;/tt&gt; operations are provided, as well as a * method to &lt;tt&gt;peek&lt;/tt&gt; at the top item on the stack, a method to test * for whether the stack is &lt;tt&gt;empty&lt;/tt&gt;, and a method to &lt;tt&gt;search&lt;/tt&gt; * the stack for an item and discover how far it is from the top. * &lt;p&gt; * When a stack is first created, it contains no items. * * &lt;p&gt;A more complete and consistent set of LIFO stack operations is * provided by the {@link Deque} interface and its implementations, which * should be used in preference to this class. For example:" />
      <item value="stack" />
      <item value="Copies into the specified array every active thread in this * thread group. If {@code recurse} is {@code true}, * this method recursively enumerates all subgroups of this * thread group and references to every active thread in these * subgroups are also included. If the array is too short to * hold all the threads, the extra threads are silently ignored. * * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount} * method to get an estimate of how big the array should be, however * &lt;i&gt;if the array is too short to hold all the threads, the extra threads * are silently ignored.&lt;/i&gt; If it is critical to obtain every active * thread in this thread group, the caller should verify that the returned * int value is strictly less than the length of {@code list}. * * &lt;p&gt; Due to the inherent race condition in this method, it is recommended * that the method only be used for debugging and monitoring purposes. *" />
      <item value="enumerate" />
      <item value="estimate" />
      <item value="Returns whether this Component can be focused." />
      <item value="Returns whether the cursor has been explicitly set for this Component. * If this method returns &lt;code&gt;false&lt;/code&gt;, this Component is inheriting * its cursor from an ancestor." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="662" />
        <entry key="ENGLISH" value="720" />
        <entry key="FRENCH" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="phoneticFontFamily" value="Meiryo UI" />
    <option name="primaryFontFamily" value="Meiryo UI" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
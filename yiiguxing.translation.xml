<application>
  <component name="AppStorage">
    <histories>
      <item value="codec" />
      <item value="Resource Manager Inbound" />
      <item value="剩余" />
      <item value="debit" />
      <item value="deduct" />
      <item value="commodity Code" />
      <item value="Purchase" />
      <item value="附加" />
      <item value="volatile" />
      <item value="effective" />
      <item value="This class * does not &amp;quot;understand&amp;quot; these differences except in the * mechanical sense that when a shared mode acquire succeeds, the next * waiting thread (if one exists) must also determine whether it can * acquire as well" />
      <item value="Shared mode * acquires by multiple threads may (but need not) succeed" />
      <item value="This class supports either or both a default &lt;em&gt;exclusive&lt;/em&gt; * mode and a &lt;em&gt;shared&lt;/em&gt; mode. When acquired in exclusive mode, * attempted acquires by other threads cannot succeed." />
      <item value="Subclasses should be defined as non-public internal helper * classes that are used to implement the synchronization properties * of their enclosing class" />
      <item value="Subclasses can maintain * other state fields, but only the atomically updated {@code int} * value manipulated using methods {@link #getState}, {@link * #setState} and {@link #compareAndSetState} is tracked with respect * to synchronization." />
      <item value="Given these, the other methods in this class carry * out all queuing and blocking mechanics." />
      <item value="mechanics" />
      <item value="Subclasses * must define the protected methods that change this state, and which * define what that state means in terms of this object being acquired * or released." />
      <item value="This class is designed to * be a useful basis for most kinds of synchronizers that rely on a * single atomic {@code int} value to represent state." />
      <item value="represent" />
      <item value="rely" />
      <item value="Provides a framework for implementing blocking locks and related * synchronizers (semaphores, events, etc) that rely on * first-in-first-out (FIFO) wait queues." />
      <item value="A synchronizer that may be exclusively owned by a thread. This * class provides a basis for creating locks and related synchronizers * that may entail a notion of ownership. The * {@code AbstractOwnableSynchronizer} class itself does not manage or * use this information. However, subclasses and tools may use * appropriately maintained values to help control and monitor access * and provide diagnostics." />
      <item value="exclusively" />
      <item value="Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a {@code volatile} read * and write." />
      <item value="The {@link java.util.concurrent.ArrayBlockingQueue} class provides * this functionality, so there is no reason to implement this * sample usage class.)" />
      <item value="obtain" />
      <item value="{@code Condition} factors out the {@code Object} monitor * methods ({@link Object#wait() wait}, {@link Object#notify notify} * and {@link Object#notifyAll notifyAll}) into distinct objects to * give the effect of having multiple wait-sets per object, by * combining them with the use of arbitrary {@link Lock} implementations. * Where a {@code Lock} replaces the use of {@code synchronized} methods * and statements, a {@code Condition} replaces the use of the Object * monitor methods." />
      <item value="Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one." />
      <item value="Convenience method to interrupt current thread. */" />
      <item value="Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire." />
      <item value="Creates and enqueues node for current thread and given mode. *" />
      <item value="self Interrupt" />
      <item value="Acquires in exclusive mode, aborting if interrupted. * Implemented by first checking interrupt status, then invoking * at least once {@link #tryAcquire}, returning on * success. Otherwise the thread is queued, possibly repeatedly * blocking and unblocking, invoking {@link #tryAcquire} * until success or the thread is interrupted. This method can be * used to implement method {@link Lock#lockInterruptibly}." />
      <item value="acquire" />
      <item value="returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking {@link * #tryAcquire} until success." />
      <item value="Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once" />
      <item value="Marker to indicate a node is waiting in exclusive mode" />
      <item value="Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock." />
      <item value="Sync object for non-fair locks */" />
      <item value="Sync object for fair locks" />
      <item value="arrange" />
      <item value="corabollate" />
      <item value="p&gt;Allows for specifying explicit constructor arguments / factory method arguments, * overriding the specified default arguments (if any) in the bean definition." />
      <item value="Return an instance, which may be shared or independent, of the specified bean." />
      <item value="Used to dereference a {@link FactoryBean} instance and distinguish it from * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject} * will return the factory, not the instance returned by the factory." />
      <item value="dereference" />
      <item value="custom init-method definition" />
      <item value="Initializing Bean" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="560" />
        <entry key="ENGLISH" value="613" />
        <entry key="FRENCH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
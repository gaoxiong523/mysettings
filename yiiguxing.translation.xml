<application>
  <component name="AppStorage">
    <histories>
      <item value="algorithm" />
      <item value="realization" />
      <item value="specification" />
      <item value="association" />
      <item value="stereotype" />
      <item value="A decoder that splits the received {@link ByteBuf}s dynamically by the * value of the Google Protocol Buffers * &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding#varints&quot;&gt;Base * 128 Varints&lt;/a&gt; integer length field in the message. For example:" />
      <item value="&lt;code&gt;DocumentFilter&lt;/code&gt;, as the name implies, is a filter for the * &lt;code&gt;Document&lt;/code&gt; mutation methods. When a &lt;code&gt;Document&lt;/code&gt; * containing a &lt;code&gt;DocumentFilter&lt;/code&gt; is modified (either through * &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt;), it forwards the appropriate * method invocation to the &lt;code&gt;DocumentFilter&lt;/code&gt;. The * default implementation allows the modification to * occur. Subclasses can filter the modifications by conditionally invoking * methods on the superclass, or invoking the necessary methods on * the passed in &lt;code&gt;FilterBypass&lt;/code&gt;. Subclasses should NOT call back * into the Document for the modification * instead call into the superclass or the &lt;code&gt;FilterBypass&lt;/code&gt;. * &lt;p&gt; * When &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; is invoked * on the &lt;code&gt;DocumentFilter&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt; * may callback into the * &lt;code&gt;FilterBypass&lt;/code&gt; multiple times, or for different regions, but * it should not callback into the &lt;code&gt;FilterBypass&lt;/code&gt; after returning * from the &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; method. * &lt;p&gt; * By default, text related document mutation methods such as * &lt;code&gt;insertString&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; * in &lt;code&gt;AbstractDocument&lt;/code&gt; use &lt;code&gt;DocumentFilter&lt;/code&gt; when * available, and &lt;code&gt;Element&lt;/code&gt; related mutation methods such as * &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; and &lt;code&gt;removeElement&lt;/code&gt; in * &lt;code&gt;DefaultStyledDocument&lt;/code&gt; do not use &lt;code&gt;DocumentFilter&lt;/code&gt;. * If a method doesn't follow these defaults, this must be explicitly stated * in the method documentation." />
      <item value="NavigationFilter implementation that calls back to methods with * same name in DefaultFormatter." />
      <item value="Invoked prior to the Caret setting the dot. The default implementation * calls directly into the &lt;code&gt;FilterBypass&lt;/code&gt; with the passed * in arguments. Subclasses may wish to conditionally * call super with a different location, or invoke the necessary method * on the &lt;code&gt;FilterBypass&lt;/code&gt;" />
      <item value="&lt;code&gt;NavigationFilter&lt;/code&gt; can be used to restrict where the cursor can * be positioned. When the default cursor positioning actions attempt to * reposition the cursor they will call into the * &lt;code&gt;NavigationFilter&lt;/code&gt;, assuming * the &lt;code&gt;JTextComponent&lt;/code&gt; has a non-null * &lt;code&gt;NavigationFilter&lt;/code&gt; set. In this manner * the &lt;code&gt;NavigationFilter&lt;/code&gt; can effectively restrict where the * cursor can be positioned. Similarly &lt;code&gt;DefaultCaret&lt;/code&gt; will call * into the &lt;code&gt;NavigationFilter&lt;/code&gt; when the user is changing the * selection to further restrict where the cursor can be positioned." />
      <item value="one should use {@code t1 - t0 &lt; 0}, not {@code t1 &lt; t0}, * because of the possibility of numerical overflow. *" />
      <item value="&lt;p&gt;The values returned by this method become meaningful only when * the difference between two such values, obtained within the same * instance of a Java virtual machine, is computed." />
      <item value="* &lt;p&gt;Differences in successive calls that span greater than * approximately 292 years (2&lt;sup&gt;63&lt;/sup&gt; nanoseconds) will not * correctly compute elapsed time due to numerical overflow." />
      <item value="p&gt;This method provides nanosecond precision, but not necessarily * nanosecond resolution (that is, how frequently the value changes) * - no guarantees are made except that the resolution is at least as * good as that of {@link #currentTimeMillis()}." />
      <item value="The value returned represents nanoseconds since some fixed but * arbitrary &lt;i&gt;origin&lt;/i&gt; time (perhaps in the future, so values * may be negative). The same origin is used by all invocations of * this method in an instance of a Java virtual machine; other * virtual machine instances are likely to use a different origin." />
      <item value="&lt;p&gt;This method can only be used to measure elapsed time and is * not related to any other notion of system or wall-clock time." />
      <item value="Returns the current value of the running Java Virtual Machine's * high-resolution time source, in nanoseconds." />
      <item value="A variant of the &quot;two lock queue&quot; algorithm. The putLock gates * entry to put (and offer), and has an associated condition for * waiting puts. Similarly for the takeLock. The &quot;count&quot; field * that they both rely on is maintained as an atomic to avoid * needing to get both locks in most cases. Also, to minimize need * for puts to get takeLock and vice-versa, cascading notifies are * used. When a put notices that it has enabled at least one take, * it signals taker. That taker in turn signals others if more * items have been entered since the signal. And symmetrically for * takes signalling puts. Operations such as remove(Object) and * iterators acquire both locks." />
      <item value="&lt;p&gt;The optional capacity bound constructor argument serves as a * way to prevent excessive queue expansion. The capacity, if unspecified, * is equal to {@link Integer#MAX_VALUE}. Linked nodes are * dynamically created upon each insertion unless this would bring the * queue above capacity." />
      <item value="This queue orders elements FIFO (first-in-first-out). * The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the * queue the longest time. * The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the * queue the shortest time. New elements * are inserted at the tail of the queue, and the queue retrieval * operations obtain elements at the head of the queue. * Linked queues typically have higher throughput than array-based queues but * less predictable performance in most concurrent applications." />
      <item value="An optionally-bounded {@linkplain BlockingQueue blocking queue} based on * linked nodes." />
      <item value="Transfers the specified source array's data to this buffer starting at * the current {@code writerIndex} and increases the {@code writerIndex} * by the number of the transferred bytes (= {@code src.length})." />
      <item value="Returns a deep clone of this bootstrap which has the identical configuration. This method is useful when making * multiple {@link Channel}s with similar settings. Please note that this method does not clone the * {@link EventLoopGroup} deeply but shallowly, making the group a shared resource." />
      <item value="Channels of this type are safe for use by multiple concurrent threads * though at most one accept operation can be outstanding at any time. * If a thread initiates an accept operation before a previous accept operation * has completed then an {@link AcceptPendingException} will be thrown." />
      <item value="An asynchronous channel for stream-oriented listening sockets." />
      <item value="devops" />
      <item value="destination" />
      <item value="This method transfers bytes from this buffer into the given * destination array. An invocation of this method of the form * &lt;tt&gt;src.get(a)&lt;/tt&gt; behaves in exactly the same way as the invocation" />
      <item value="Relative bulk &lt;i&gt;get&lt;/i&gt; method." />
      <item value="After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke * this method to prepare for a sequence of channel-write or relative" />
      <item value="Flips this buffer. The limit is set to the current position and then * the position is set to zero. If the mark is defined then it is * discarded." />
      <item value="Flips" />
      <item value="An invocation of this method of the form &lt;tt&gt;k.isAcceptable()&lt;/tt&gt; * behaves in exactly the same way as the expression" />
      <item value="Tests whether this key's channel is ready to accept a new socket * connection." />
      <item value="p&gt; A key is valid upon creation and remains so until it is cancelled, * its channel is closed, or its selector is closed. &lt;/p&gt;" />
      <item value="valid" />
      <item value="Returns the approximate total number of tasks that have ever been * scheduled for execution. Because the states of tasks and * threads may change dynamically during computation, the returned * value is only an approximation." />
      <item value="Ecosystem" />
      <item value="Calls {@link ChannelHandlerContext#fireChannelReadComplete()} to forward * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}. * * Sub-classes may override this method to change behavior." />
      <item value="Return the value if present, otherwise return {@code other}." />
      <item value="present" />
      <item value="Adapter to delegate serialization/deserialization to {@link RedisSerializer}." />
      <item value="portal" />
      <item value="&lt;p&gt;Usages of this class should typically be of the form: * {@code ThreadLocalRandom.current().nextX(...)} (where * {@code X} is {@code Int}, {@code Long}, etc). * When all usages are of this form, it is never possible to * accidently share a {@code ThreadLocalRandom} across multiple threads." />
      <item value="A random number generator isolated to the current thread. Like the * global {@link java.util.Random} generator used by the {@link * java.lang.Math} class, a {@code ThreadLocalRandom} is initialized * with an internally generated seed that may not otherwise be * modified. When applicable, use of {@code ThreadLocalRandom} rather * than shared {@code Random} objects in concurrent programs will * typically encounter much less overhead and contention. Use of * {@code ThreadLocalRandom} is particularly appropriate when multiple * tasks (for example, each a {@link ForkJoinTask}) use random numbers * in parallel in thread pools." />
      <item value="A random number generator isolated to the current thread." />
      <item value="invokers" />
      <item value="Returns &lt;code&gt;true&lt;/code&gt; as soon as the lock is acquired. * If the lock is currently held by another thread in this or any * other process in the distributed system this method keeps trying * to acquire the lock for up to &lt;code&gt;waitTime&lt;/code&gt; before * giving up and returning &lt;code&gt;false&lt;/code&gt;. If the lock is acquired, * it is held until &lt;code&gt;unlock&lt;/code&gt; is invoked, or until &lt;code&gt;leaseTime&lt;/code&gt; * have passed since the lock was granted - whichever comes first." />
      <item value="Demarcates a property to be used as version field to implement optimistic locking on entities. *" />
      <item value="&gt; The &lt;code&gt;Version&lt;/code&gt; property should be mapped to * the primary table for the entity class; applications that * map the &lt;code&gt;Version&lt;/code&gt; property to a table other than * the primary table will not be portable." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="624" />
        <entry key="ENGLISH" value="677" />
        <entry key="FRENCH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="false" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="phoneticFontFamily" value="Meiryo UI" />
    <option name="primaryFontFamily" value="Meiryo UI" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
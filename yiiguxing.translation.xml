<application>
  <component name="AppStorage">
    <histories>
      <item value="considering" />
      <item value="capabilities " />
      <item value="adjust" />
      <item value="affix" />
      <item value="测校" />
      <item value="终止" />
      <item value="组件" />
      <item value="自定义" />
      <item value="Demarcates an identifier." />
      <item value="The request was rejected because the HTTP method &quot;JSON&quot; was not included within the whitelis" />
      <item value="whitelisted" />
      <item value="please provide an explicit mapping using Jackson annotations or by providing a Mixin." />
      <item value="A container for settings for the generation of getters and setters." />
      <item value="argument type mismatch" />
      <item value="Cannot determine value type from string" />
      <item value="declare" />
      <item value="section" />
      <item value="warning: GOPATH set to GOROOT (C:\Go) has no effect package github.com/astaxie/beego/...: cannot download, $GOPATH must not be set to $GOROOT. For more details see: 'go help gopath'" />
      <item value="frequency" />
      <item value="axure" />
      <item value="观察" />
      <item value="Set-up a fetch request for any node that we have assigned partitions for which doesn't already have * an in-flight fetch or pending fetch data." />
      <item value="硅片" />
      <item value="view wafer properties" />
      <item value="restore" />
      <item value="功能入口" />
      <item value="maintain" />
      <item value="软件介绍" />
      <item value="terminate" />
      <item value="迷宫" />
      <item value="Pessimistic" />
      <item value="Synonymous" />
      <item value="Optimistic" />
      <item value="predicate" />
      <item value="composed" />
      <item value="数据结构" />
      <item value="Thrashing might happen." />
      <item value="federation" />
      <item value="fedaration" />
      <item value="vital" />
      <item value="regarding " />
      <item value="过滤器Bit Map在64位机器上.这个类能发生更好的效果.一般机器不建议使用" />
      <item value="durably" />
      <item value="排行榜" />
      <item value="As a further improvement, notice that the left task need not even exist. * Instead of creating a new one, we can iterate using the original task, * and add a pending count for each fork. Additionally, because no task * in this tree implements an {@link #onCompletion(CountedCompleter)} method, * {@code tryComplete()} can be replaced with {@link #propagateCompletion}." />
      <item value="This design can be improved by noticing that in the recursive case, * the task has nothing to do after forking its right task, so can * directly invoke its left task before returning. (This is an analog * of tail recursion removal.) Also, because the task returns upon * executing its left task (rather than falling through to invoke * {@code tryComplete}) the pending count is set to one:" />
      <item value="* &lt;p&gt;For example, here is an initial version of a class that uses * divide-by-two recursive decomposition to divide work into single * pieces (leaf tasks). Even when work is split into individual calls, * tree-based techniques are usually preferable to directly forking * leaf tasks, because they reduce inter-thread communication and * improve load balancing. In the recursive case, the second of each * pair of subtasks to finish triggers completion of its parent * (because no result combination is performed, the default no-op * implementation of method {@code onCompletion} is not overridden). * A static utility method sets up the base task and invokes it * (here, implicitly using the {@link ForkJoinPool#commonPool()})." />
      <item value="Parallel recursive decomposition." />
      <item value="Unless initialized otherwise, the {@linkplain #getPendingCount pending * count} starts at zero, but may be (atomically) changed using * methods {@link #setPendingCount}, {@link #addToPendingCount}, and * {@link #compareAndSetPendingCount}. Upon invocation of {@link * #tryComplete}, if the pending action count is nonzero, it is * decremented; otherwise, the completion action is performed, and if * this completer itself has a completer, the process is continued * with its completer. As is the case with related synchronization * components such as {@link java.util.concurrent.Phaser Phaser} and * {@link java.util.concurrent.Semaphore Semaphore}, these methods * affect only internal counts; they do not establish any further * internal bookkeeping. In particular, the identities of pending * tasks are not maintained. As illustrated below, you can create * subclasses that do record some or all pending tasks or their * results when needed. As illustrated below, utility methods * supporting customization of completion traversals are also * provided. However, because CountedCompleters provide only basic * synchronization mechanisms, it may be useful to create further * abstract subclasses that maintain linkages, fields, and additional * support methods appropriate for a set of related usages." />
      <item value="Uses of * CountedCompleter are similar to those of other completion based * components (such as {@link java.nio.channels.CompletionHandler}) * except that multiple &lt;em&gt;pending&lt;/em&gt; completions may be necessary * to trigger the completion action {@link #onCompletion(CountedCompleter)}, * not just one." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="710" />
        <entry key="ENGLISH" value="781" />
        <entry key="GERMAN" value="4" />
        <entry key="FRENCH" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="phoneticFontFamily" value="Meiryo UI" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="translator" value="ai.youdao" />
    <option name="ttsSource" value="TRANSLATION" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
      </youdao-translate>
    </option>
  </component>
</application>
<application>
  <component name="AppStorage">
    <histories>
      <item value="Authorization Server Security Configurer" />
      <item value="sequential" />
      <item value="to classify a filter by type. Standard types in Zuul are &quot;pre&quot; for pre-routing filtering, * &quot;route&quot; for routing to an origin, &quot;post&quot; for post-routing filters, &quot;error&quot; for error handling." />
      <item value="determines" />
      <item value="accredit" />
      <item value="(If none of the installed providers supply an implementation of * {@code SecureRandom}, a system-provided source of randomness is * used.)." />
      <item value="nitializes the key pair generator using the specified parameter * set and the {@code SecureRandom} * implementation of the highest-priority installed provider as the source * of randomness." />
      <item value="the source of randomness for this generator." />
      <item value="This is an * algorithm-specific metric, such as modulus length, specified in * number of bits." />
      <item value="This instance is immutable * and unaffected by this method call." />
      <item value="specified" />
      <item value="Returns a copy of this {@link ExampleMatcher} with the specified {@code propertyPaths}. This instance is immutable * and unaffected by this method call." />
      <item value="Create a new {@link ExampleMatcher} including all non-null properties by default matching &lt;strong&gt;all&lt;/strong&gt; * predicates derived from the example." />
      <item value="Create a new {@link ExampleMatcher} including all non-null properties by default matching &lt;strong&gt;any&lt;/strong&gt; * predicate derived from the example." />
      <item value="Rejecting" />
      <item value="Implementation note. A previous version of this class was * internally structured a little differently. Because superclass * HashMap now uses trees for some of its nodes, class * LinkedHashMap.Entry is now treated as intermediary node class * that can also be converted to tree form. The name of this * class, LinkedHashMap.Entry, is confusing in several ways in its * current context, but cannot be changed. Otherwise, even though * it is not exported outside this package, some existing source * code is known to have relied on a symbol resolution corner case * rule in calls to removeEldestEntry that suppressed compilation * errors due to ambiguous usages. So, we keep the name to * preserve unmodified compilability. * * The changes in node classes also require using two fields * (head, tail) rather than a pointer to a header node to maintain * the doubly-linked before/after list. This class also * previously used a different style of callback methods upon * access, insertion, and removal." />
      <item value="A structural modification is any operation that adds or deletes one or more * mappings or, in the case of access-ordered linked hash maps, affects * iteration order. In insertion-ordered linked hash maps, merely changing * the value associated with a key that is already contained in the map is not * a structural modification. &lt;strong&gt;In access-ordered linked hash maps, * merely querying the map with &lt;tt&gt;get&lt;/tt&gt; is a structural modification. * &lt;/strong&gt;) *" />
      <item value="&lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a linked hash map concurrently, and at least * one of the threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be * synchronized externally. This is typically accomplished by * synchronizing on some object that naturally encapsulates the map." />
      <item value="If no such object exists, the map should be &quot;wrapped&quot; using the * {@link Collections#synchronizedMap Collections.synchronizedMap} * method. This is best done at creation time, to prevent accidental * unsynchronized access to the map:&lt;pre&gt; * Map m = Collections.synchronizedMap(new LinkedHashMap(...));&lt;/pre&gt; *" />
      <item value="&lt;p&gt;A linked hash map has two parameters that affect its performance: * &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. They are defined precisely * as for &lt;tt&gt;HashMap&lt;/tt&gt;. Note, however, that the penalty for choosing an * excessively high value for initial capacity is less severe for this class * than for &lt;tt&gt;HashMap&lt;/tt&gt;, as iteration times for this class are unaffected * by capacity." />
      <item value="Performance is likely to be just slightly * below that of &lt;tt&gt;HashMap&lt;/tt&gt;, due to the added expense of maintaining the * linked list, with one exception: Iteration over the collection-views * of a &lt;tt&gt;LinkedHashMap&lt;/tt&gt; requires time proportional to the &lt;i&gt;size&lt;/i&gt; * of the map, regardless of its capacity. Iteration over a &lt;tt&gt;HashMap&lt;/tt&gt; * is likely to be more expensive, requiring time proportional to its * &lt;i&gt;capacity&lt;/i&gt;." />
      <item value="&gt;This class provides all of the optional &lt;tt&gt;Map&lt;/tt&gt; operations, and * permits null elements. Like &lt;tt&gt;HashMap&lt;/tt&gt;, it provides constant-time * performance for the basic operations (&lt;tt&gt;add&lt;/tt&gt;, &lt;tt&gt;contains&lt;/tt&gt; and * &lt;tt&gt;remove&lt;/tt&gt;), assuming the hash function disperses elements * properly among the buckets" />
      <item value="&gt;The {@link #removeEldestEntry(Map.Entry)} method may be overridden to * impose a policy for removing stale mappings automatically when new mappings * are added to the map." />
      <item value="In particular, operations * on collection-views do &lt;i&gt;not&lt;/i&gt; affect the order of iteration of the * backing map." />
      <item value="The {@code replace} methods only result in an access * of the entry if the value is replaced. The {@code putAll} method generates one * entry access for each mapping in the specified map, in the order that * key-value mappings are provided by the specified map's entry set iterator. * &lt;i&gt;No other methods generate entry accesses.&lt;/i&gt; In particular, operations * on collection-views do &lt;i&gt;not&lt;/i&gt; affect the order of iteration of the * backing map." />
      <item value="This kind of map is well-suited to * building LRU caches. Invoking the {@code put}, {@code putIfAbsent}, * {@code get}, {@code getOrDefault}, {@code compute}, {@code computeIfAbsent}, * {@code computeIfPresent}, or {@code merge} methods results * in an access to the corresponding entry (assuming it exists after the * invocation completes)." />
      <item value="&gt;A special {@link #LinkedHashMap(int,float,boolean) constructor} is * provided to create a linked hash map whose order of iteration is the order * in which its entries were last accessed, from least-recently accessed to * most-recently (&lt;i&gt;access-order&lt;/i&gt;)." />
      <item value="This technique is particularly useful if a module takes a map on input, * copies it, and later returns results whose order is determined by that of * the copy. (Clients generally appreciate having things returned in the same * order they were presented.)" />
      <item value="This implementation spares its clients from the unspecified, generally * chaotic ordering provided by {@link HashMap} (and {@link Hashtable}), * without incurring the increased cost associated with {@link TreeMap}." />
      <item value="(A key &lt;tt&gt;k&lt;/tt&gt; is * reinserted into a map &lt;tt&gt;m&lt;/tt&gt; if &lt;tt&gt;m.put(k, v)&lt;/tt&gt; is invoked when * &lt;tt&gt;m.containsKey(k)&lt;/tt&gt; would return &lt;tt&gt;true&lt;/tt&gt; immediately prior to * the invocation.)" />
      <item value="Note that insertion order is not affected * if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map." />
      <item value="This linked list defines the iteration ordering, * which is normally the order in which keys were inserted into the map * (&lt;i&gt;insertion-order&lt;/i&gt;)." />
      <item value="This implementation differs from * &lt;tt&gt;HashMap&lt;/tt&gt; in that it maintains a doubly-linked list running through * all of its entries." />
      <item value="Hash table and linked list implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface, * with predictable iteration order." />
      <item value="Stores a file on the server using the given name and taking input * from the given InputStream. This method does NOT close the given * InputStream. If the current file type is ASCII, line separators in * the file are transparently converted to the NETASCII format (i.e., * you should not attempt to create a special InputStream to do this)." />
      <item value="Stores" />
      <item value="Protocol Command Listener" />
      <item value="deprecated " />
      <item value="Priority Blocking Queue" />
      <item value="Synchronous Queue" />
      <item value="We don't care about the other features of the base class, just want to // handle the request" />
      <item value="features" />
      <item value="This uses a basic token bucket algorithm and relies on the fact that Redis scripts * execute atomically. No other operations can run between fetching the count and * writing the new count." />
      <item value="Resources are loaded from the current thread's * {@link Thread#getContextClassLoader()}. In general, a library needs its * configuration to come from the class loader used to load that library, so * the proper &quot;reference.conf&quot; are present." />
      <item value="Loads an application's configuration from the given classpath resource or * classpath resource basename, sandwiches it between default reference * config and default overrides, and then resolves it. The classpath * resource is &quot;raw&quot; (it should have no &quot;/&quot; prefix, and is not made relative * to any package, so it's like {@link ClassLoader#getResource} not * {@link Class#getResource})." />
      <item value="Defines the set of cascadable operations that are propagated * to the associated entity. * The value &lt;code&gt;cascade=ALL&lt;/code&gt; is equivalent to * &lt;code&gt;cascade={PERSIST, MERGE, REMOVE, REFRESH, DETACH}&lt;/code&gt;." />
      <item value="multiplicity" />
      <item value="association" />
      <item value="Specifies" />
      <item value="Deprecated" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="312" />
        <entry key="ENGLISH" value="364" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
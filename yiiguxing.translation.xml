<application>
  <component name="AppStorage">
    <histories>
      <item value="Insertion into a CLH queue requires only a single atomic * operation on &quot;tail&quot;, so there is a simple atomic point of * demarcation from unqueued to queued. Similarly, dequeuing * involves only updating the &quot;head&quot;. However, it takes a bit * more work for nodes to determine who their successors are, * in part to deal with possible cancellation due to timeouts * and interrupts." />
      <item value="tactic" />
      <item value="A thread may try to acquire if it is * first in the queue. But being first does not guarantee success; * it only gives the right to contend. So the currently released * contender thread may need to rewait." />
      <item value="CLH locks are normally used for * spinlocks." />
      <item value="Craig" />
      <item value="The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and * Hagersten) lock queue." />
      <item value="Abstract Queued Synchronizer" />
      <item value="Instead it defines methods such as * {@link #acquireInterruptibly} that can be invoked as * appropriate by concrete locks and related synchronizers to * implement their public methods." />
      <item value="Class * {@code AbstractQueuedSynchronizer} does not implement any * synchronization interface." />
      <item value="&gt;Subclasses should be defined as non-public internal helper * classes that are used to implement the synchronization properties * of their enclosing class." />
      <item value="Provides a framework for implementing blocking locks and related * synchronizers (semaphores, events, etc) that rely on * first-in-first-out (FIFO) wait queues. This class is designed to * be a useful basis for most kinds of synchronizers that rely on a * single atomic {@code int} value to represent state. Subclasses * must define the protected methods that change this state, and which * define what that state means in terms of this object being acquired * or released. Given these, the other methods in this class carry * out all queuing and blocking mechanics. Subclasses can maintain * other state fields, but only the atomically updated {@code int} * value manipulated using methods {@link #getState}, {@link * #setState} and {@link #compareAndSetState} is tracked with respect * to synchronization." />
      <item value="Uses AQS state * to represent permits. Subclassed into fair and nonfair * versions." />
      <item value="Synchronization implementation for semaphore." />
      <item value="material" />
      <item value="Releases a permit, returning it to the semaphore." />
      <item value="deprecated" />
      <item value="deprected" />
      <item value="accessor" />
      <item value="General delegate for around-advice-based subclasses, delegating to several other template * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager} * as well as regular {@link PlatformTransactionManager} implementations." />
      <item value="AOP Alliance MethodInterceptor for declarative transaction * management using the common Spring transaction infrastructure * ({@link org.springframework.transaction.PlatformTransactionManager}). * * &lt;p&gt;Derives from the {@link TransactionAspectSupport} class which * contains the integration with Spring's underlying transaction API. * TransactionInterceptor simply calls the relevant superclass methods * such as {@link #invokeWithinTransaction} in the correct order." />
      <item value="enroll" />
      <item value="倒序" />
      <item value="顺序" />
      <item value="azkaban" />
      <item value="azkanban" />
      <item value="hive" />
      <item value="oozie" />
      <item value="This class implements the Dual-Pivot Quicksort algorithm by * Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm * offers O(n log(n)) performance on many data sets that cause other * quicksorts to degrade to quadratic performance, and is typically * faster than traditional (one-pivot) Quicksort implementations. * * All exposed methods are package-private, designed to be invoked * from public methods (in class Arrays) after performing any * necessary array bounds checks and expanding parameters into the * required forms." />
      <item value="Searches the specified array of longs for the specified value using the * binary search algorithm. The array must be sorted (as * by the {@link #sort(long[])} method) prior to making this call. If it * is not sorted, the results are undefined. If the array contains * multiple elements with the specified value, there is no guarantee which * one will be found." />
      <item value="归并排序" />
      <item value="快速排序" />
      <item value="插入排序" />
      <item value="插入" />
      <item value="冒泡" />
      <item value="Central interface to provide configuration for an application. * This is read-only while the application is running, but may be * reloaded if the implementation supports this." />
      <item value="This interface represents a naming context, which * consists of a set of name-to-object bindings. * It contains methods for examining and updating these bindings." />
      <item value="Contains methods for registering/deregistering listeners to be notified of * events fired when objects named in a context changes." />
      <item value="ass" />
      <item value="* &lt;p&gt;A min-max priority queue can be configured with a maximum size. If so, * each time the size of the queue exceeds that value, the queue automatically * removes its greatest element according to its comparator (which might be the * element that was just added). This is different from conventional bounded * queues, which either block or reject new elements when full. *" />
      <item value="* &lt;p&gt;As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its * head element -- the implicit target of the methods {@link #peek()}, {@link * #poll()} and {@link #remove()} -- is defined as the &lt;i&gt;least&lt;/i&gt; element in * the queue according to the queue's comparator. But unlike a regular priority * queue, the methods {@link #peekLast}, {@link #pollLast} and * {@link #removeLast} are also provided, to act on the &lt;i&gt;greatest&lt;/i&gt; element * in the queue instead." />
      <item value="A double-ended priority queue, which provides constant-time access to both * its least element and its greatest element, as determined by the queue's * specified comparator. If no comparator is given at construction time, the * natural order of elements is used." />
      <item value="* An unbounded priority {@linkplain Queue queue} based on a priority heap. * The elements of the priority queue are ordered according to their * {@linkplain Comparable natural ordering}, or by a {@link Comparator} * provided at queue construction time, depending on which constructor is * used. A priority queue does not permit {@code null} elements. * A priority queue relying on natural ordering also does not permit * insertion of non-comparable objects (doing so may result in * {@code ClassCastException}). *" />
      <item value="* &lt;p&gt;The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element * with respect to the specified ordering. If multiple elements are * tied for least value, the head is one of those elements -- ties are * broken arbitrarily. The queue retrieval operations {@code poll}, * {@code remove}, {@code peek}, and {@code element} access the * element at the head of the queue." />
      <item value="&lt;p&gt;A priority queue is unbounded, but has an internal * &lt;i&gt;capacity&lt;/i&gt; governing the size of an array used to store the * elements on the queue. It is always at least as large as the queue * size. As elements are added to a priority queue, its capacity * grows automatically. The details of the growth policy are not * specified." />
      <item value="&lt;p&gt;This class and its iterator implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link * Iterator} interfaces. The Iterator provided in method {@link * #iterator()} is &lt;em&gt;not&lt;/em&gt; guaranteed to traverse the elements of * the priority queue in any particular order. If you need ordered * traversal, consider using {@code Arrays.sort(pq.toArray())}. *" />
      <item value="A priority queue relying on natural ordering also does not permit * insertion of non-comparable objects (doing so may result in * {@code ClassCastException})." />
      <item value="An unbounded priority {@linkplain Queue queue} based on a priority heap." />
      <item value="priority" />
      <item value="unbounded" />
      <item value="The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a {@code FunctionalInterface} * annotation is present on the interface declaration." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="678" />
        <entry key="ENGLISH" value="735" />
        <entry key="FRENCH" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Meiryo UI" />
    <option name="primaryFontFamily" value="Meiryo UI" />
    <option name="translator" value="ai.youdao" />
    <option name="ttsSource" value="TRANSLATION" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
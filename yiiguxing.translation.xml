<application>
  <component name="AppStorage">
    <histories>
      <item value="The {@link java.util.concurrent.ArrayBlockingQueue} class provides * this functionality, so there is no reason to implement this * sample usage class.)" />
      <item value="obtain" />
      <item value="{@code Condition} factors out the {@code Object} monitor * methods ({@link Object#wait() wait}, {@link Object#notify notify} * and {@link Object#notifyAll notifyAll}) into distinct objects to * give the effect of having multiple wait-sets per object, by * combining them with the use of arbitrary {@link Lock} implementations. * Where a {@code Lock} replaces the use of {@code synchronized} methods * and statements, a {@code Condition} replaces the use of the Object * monitor methods." />
      <item value="Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one." />
      <item value="Convenience method to interrupt current thread. */" />
      <item value="Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire." />
      <item value="Creates and enqueues node for current thread and given mode. *" />
      <item value="self Interrupt" />
      <item value="Acquires in exclusive mode, aborting if interrupted. * Implemented by first checking interrupt status, then invoking * at least once {@link #tryAcquire}, returning on * success. Otherwise the thread is queued, possibly repeatedly * blocking and unblocking, invoking {@link #tryAcquire} * until success or the thread is interrupted. This method can be * used to implement method {@link Lock#lockInterruptibly}." />
      <item value="acquire" />
      <item value="returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking {@link * #tryAcquire} until success." />
      <item value="Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once" />
      <item value="Marker to indicate a node is waiting in exclusive mode" />
      <item value="Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock." />
      <item value="Sync object for non-fair locks */" />
      <item value="Sync object for fair locks" />
      <item value="arrange" />
      <item value="corabollate" />
      <item value="p&gt;Allows for specifying explicit constructor arguments / factory method arguments, * overriding the specified default arguments (if any) in the bean definition." />
      <item value="Return an instance, which may be shared or independent, of the specified bean." />
      <item value="Used to dereference a {@link FactoryBean} instance and distinguish it from * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject} * will return the factory, not the instance returned by the factory." />
      <item value="dereference" />
      <item value="custom init-method definition" />
      <item value="Initializing Bean" />
      <item value="methods of BeanPostProcessors" />
      <item value="Servlet Context Aware" />
      <item value="Application Context Aware" />
      <item value="Message Source Aware" />
      <item value="Application Event Publisher Aware" />
      <item value="Resource Loader Aware" />
      <item value="Embedded Value Resolver Aware" />
      <item value="Environment Aware" />
      <item value="Bean Name Aware's" />
      <item value="Aware" />
      <item value="Bean Class Loader Aware" />
      <item value="Bean Name Aware" />
      <item value="&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:" />
      <item value="In contrast to the methods in {@link ListableBeanFactory}, all of the * operations in this interface will also check parent factories if this is a * {@link HierarchicalBeanFactory}. If a bean is not found in this factory instance, * the immediate parent factory will be asked. Beans in this factory instance * are supposed to override beans of the same name in any parent factory." />
      <item value="Hierarchical" />
      <item value="There are no * constraints on how the definitions could be stored: LDAP, RDBMS, XML, * properties file, etc. Implementations are encouraged to support references * amongst beans (Dependency Injection)." />
      <item value="However, an implementation could simply return * Java objects it creates as necessary directly in Java code." />
      <item value="However" />
      <item value="Normally a BeanFactory will load bean definitions stored in a configuration * source (such as an XML document), and use the {@code org.springframework.beans} * package to configure the beans." />
      <item value="Spring's Dependency Injection functionality is * implemented using this BeanFactory interface and its subinterfaces." />
      <item value="subinterfaces" />
      <item value="&gt;Note that it is generally better to rely on Dependency Injection * (&quot;push&quot; configuration) to configure application objects through setters * or constructors, rather than use any form of &quot;pull&quot; configuration like a * BeanFactory lookup." />
      <item value="approach" />
      <item value="See chapters 4 and 11 of &quot;Expert One-on-One J2EE Design and * Development&quot; for a discussion of the benefits of this approach." />
      <item value="The point of this approach is that the BeanFactory is a central registry * of application components, and centralizes configuration of application * components (no more do individual objects need to read properties files, * for example)" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="534" />
        <entry key="ENGLISH" value="585" />
        <entry key="FRENCH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
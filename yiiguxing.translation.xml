<application>
  <component name="AppStorage">
    <histories>
      <item value="intercepted" />
      <item value="Strategy for enhancing an access token before it is stored by an {@link AuthorizationServerTokenServices} * implementation." />
      <item value="Helper that translates between JWT encoded token values and OAuth authentication * information (in both directions). Also acts as a {@link TokenEnhancer} when tokens are * granted." />
      <item value="Enables Spring Security global method security similar to the &amp;lt;global-method-security&amp;gt;" />
      <item value="The following annotations are annotated with {@link EnableGlobalAuthentication}" />
      <item value="authenticated" />
      <item value="is Account Non Expired" />
      <item value="is Account Non Locked" />
      <item value="is Credentials Non Expired" />
      <item value="A user approval handler that remembers approval decisions by consulting existing tokens" />
      <item value="approval" />
      <item value="AuthorizationServerEndpointsConfigurer" />
      <item value="authorize Requests" />
      <item value="Configures the {@link AuditorAware} bean to be used to lookup the current principal." />
      <item value="PA entity listener to capture auditing information on persiting and updating entities. To get this one flying be * sure you configure it as entity listener in your {@code orm.xml} as follows:" />
      <item value="legacy" />
      <item value="Client Details Service" />
      <item value="Resource Server Token Services" />
      <item value="principal" />
      <item value="credentials" />
      <item value="Convenience annotation for enabling an Authorization Server (i.e. an {@link AuthorizationEndpoint} and a * {@link TokenEndpoint}) in the current application context, which must be a {@link DispatcherServlet} context. Many * features of the server can be customized using &lt;code&gt;@Beans&lt;/code&gt; of type {@link AuthorizationServerConfigurer} * (e.g. by extending {@link AuthorizationServerConfigurerAdapter}). The user is responsible for securing the * Authorization Endpoint (/oauth/authorize) using normal Spring Security features ({@link EnableWebSecurity * &amp;#064;EnableWebSecurity} etc.), but the Token Endpoint (/oauth/token) will be automatically secured using HTTP Basic * authentication on the client's credentials. Clients &lt;em&gt;must&lt;/em&gt; be registered by providing a * {@link ClientDetailsService} through one or more AuthorizationServerConfigurers." />
      <item value="Sets up a Zuul server endpoint and installs some reverse proxy filters in it, so it can * forward requests to backend servers. The backends can be registered manually through * configuration or via DiscoveryClient. * * @see EnableZuulServer for how to get a Zuul server without any proxying" />
      <item value="Set up the application to act as a generic Zuul server without any built-in reverse * proxy features. The routes into the Zuul server can be configured through * {@link ZuulProperties} (by default there are none)." />
      <item value="Circuit Breaker" />
      <item value="ets up a Zuul server endpoint and installs some reverse proxy filters in it, so it can * forward requests to backend servers. The backends can be registered manually through * configuration or via DiscoveryClient." />
      <item value="Set up the application to act as a generic Zuul server without any built-in reverse * proxy features. The routes into the Zuul server can be configured through" />
      <item value="SneakyThrow will avoid javac's insistence that you either catch or throw onward any checked exceptions that * statements in your method body declare they generate." />
      <item value="check Token Access" />
      <item value="token Key Access" />
      <item value="allow Form Authentication For Clients" />
      <item value="Authorization Server Security Configurer" />
      <item value="sequential" />
      <item value="to classify a filter by type. Standard types in Zuul are &quot;pre&quot; for pre-routing filtering, * &quot;route&quot; for routing to an origin, &quot;post&quot; for post-routing filters, &quot;error&quot; for error handling." />
      <item value="determines" />
      <item value="accredit" />
      <item value="(If none of the installed providers supply an implementation of * {@code SecureRandom}, a system-provided source of randomness is * used.)." />
      <item value="nitializes the key pair generator using the specified parameter * set and the {@code SecureRandom} * implementation of the highest-priority installed provider as the source * of randomness." />
      <item value="the source of randomness for this generator." />
      <item value="This is an * algorithm-specific metric, such as modulus length, specified in * number of bits." />
      <item value="This instance is immutable * and unaffected by this method call." />
      <item value="specified" />
      <item value="Returns a copy of this {@link ExampleMatcher} with the specified {@code propertyPaths}. This instance is immutable * and unaffected by this method call." />
      <item value="Create a new {@link ExampleMatcher} including all non-null properties by default matching &lt;strong&gt;all&lt;/strong&gt; * predicates derived from the example." />
      <item value="Create a new {@link ExampleMatcher} including all non-null properties by default matching &lt;strong&gt;any&lt;/strong&gt; * predicate derived from the example." />
      <item value="Rejecting" />
      <item value="Implementation note. A previous version of this class was * internally structured a little differently. Because superclass * HashMap now uses trees for some of its nodes, class * LinkedHashMap.Entry is now treated as intermediary node class * that can also be converted to tree form. The name of this * class, LinkedHashMap.Entry, is confusing in several ways in its * current context, but cannot be changed. Otherwise, even though * it is not exported outside this package, some existing source * code is known to have relied on a symbol resolution corner case * rule in calls to removeEldestEntry that suppressed compilation * errors due to ambiguous usages. So, we keep the name to * preserve unmodified compilability. * * The changes in node classes also require using two fields * (head, tail) rather than a pointer to a header node to maintain * the doubly-linked before/after list. This class also * previously used a different style of callback methods upon * access, insertion, and removal." />
      <item value="A structural modification is any operation that adds or deletes one or more * mappings or, in the case of access-ordered linked hash maps, affects * iteration order. In insertion-ordered linked hash maps, merely changing * the value associated with a key that is already contained in the map is not * a structural modification. &lt;strong&gt;In access-ordered linked hash maps, * merely querying the map with &lt;tt&gt;get&lt;/tt&gt; is a structural modification. * &lt;/strong&gt;) *" />
      <item value="&lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a linked hash map concurrently, and at least * one of the threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be * synchronized externally. This is typically accomplished by * synchronizing on some object that naturally encapsulates the map." />
      <item value="If no such object exists, the map should be &quot;wrapped&quot; using the * {@link Collections#synchronizedMap Collections.synchronizedMap} * method. This is best done at creation time, to prevent accidental * unsynchronized access to the map:&lt;pre&gt; * Map m = Collections.synchronizedMap(new LinkedHashMap(...));&lt;/pre&gt; *" />
      <item value="&lt;p&gt;A linked hash map has two parameters that affect its performance: * &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. They are defined precisely * as for &lt;tt&gt;HashMap&lt;/tt&gt;. Note, however, that the penalty for choosing an * excessively high value for initial capacity is less severe for this class * than for &lt;tt&gt;HashMap&lt;/tt&gt;, as iteration times for this class are unaffected * by capacity." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="344" />
        <entry key="ENGLISH" value="396" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
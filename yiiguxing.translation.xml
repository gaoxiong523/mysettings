<application>
  <component name="AppStorage">
    <histories>
      <item value="argument type mismatch" />
      <item value="Cannot determine value type from string" />
      <item value="declare" />
      <item value="section" />
      <item value="warning: GOPATH set to GOROOT (C:\Go) has no effect package github.com/astaxie/beego/...: cannot download, $GOPATH must not be set to $GOROOT. For more details see: 'go help gopath'" />
      <item value="frequency" />
      <item value="axure" />
      <item value="观察" />
      <item value="Set-up a fetch request for any node that we have assigned partitions for which doesn't already have * an in-flight fetch or pending fetch data." />
      <item value="硅片" />
      <item value="view wafer properties" />
      <item value="restore" />
      <item value="功能入口" />
      <item value="maintain" />
      <item value="软件介绍" />
      <item value="terminate" />
      <item value="迷宫" />
      <item value="Pessimistic" />
      <item value="Synonymous" />
      <item value="Optimistic" />
      <item value="predicate" />
      <item value="composed" />
      <item value="数据结构" />
      <item value="Thrashing might happen." />
      <item value="federation" />
      <item value="fedaration" />
      <item value="vital" />
      <item value="regarding " />
      <item value="过滤器Bit Map在64位机器上.这个类能发生更好的效果.一般机器不建议使用" />
      <item value="durably" />
      <item value="排行榜" />
      <item value="As a further improvement, notice that the left task need not even exist. * Instead of creating a new one, we can iterate using the original task, * and add a pending count for each fork. Additionally, because no task * in this tree implements an {@link #onCompletion(CountedCompleter)} method, * {@code tryComplete()} can be replaced with {@link #propagateCompletion}." />
      <item value="This design can be improved by noticing that in the recursive case, * the task has nothing to do after forking its right task, so can * directly invoke its left task before returning. (This is an analog * of tail recursion removal.) Also, because the task returns upon * executing its left task (rather than falling through to invoke * {@code tryComplete}) the pending count is set to one:" />
      <item value="* &lt;p&gt;For example, here is an initial version of a class that uses * divide-by-two recursive decomposition to divide work into single * pieces (leaf tasks). Even when work is split into individual calls, * tree-based techniques are usually preferable to directly forking * leaf tasks, because they reduce inter-thread communication and * improve load balancing. In the recursive case, the second of each * pair of subtasks to finish triggers completion of its parent * (because no result combination is performed, the default no-op * implementation of method {@code onCompletion} is not overridden). * A static utility method sets up the base task and invokes it * (here, implicitly using the {@link ForkJoinPool#commonPool()})." />
      <item value="Parallel recursive decomposition." />
      <item value="Unless initialized otherwise, the {@linkplain #getPendingCount pending * count} starts at zero, but may be (atomically) changed using * methods {@link #setPendingCount}, {@link #addToPendingCount}, and * {@link #compareAndSetPendingCount}. Upon invocation of {@link * #tryComplete}, if the pending action count is nonzero, it is * decremented; otherwise, the completion action is performed, and if * this completer itself has a completer, the process is continued * with its completer. As is the case with related synchronization * components such as {@link java.util.concurrent.Phaser Phaser} and * {@link java.util.concurrent.Semaphore Semaphore}, these methods * affect only internal counts; they do not establish any further * internal bookkeeping. In particular, the identities of pending * tasks are not maintained. As illustrated below, you can create * subclasses that do record some or all pending tasks or their * results when needed. As illustrated below, utility methods * supporting customization of completion traversals are also * provided. However, because CountedCompleters provide only basic * synchronization mechanisms, it may be useful to create further * abstract subclasses that maintain linkages, fields, and additional * support methods appropriate for a set of related usages." />
      <item value="Uses of * CountedCompleter are similar to those of other completion based * components (such as {@link java.nio.channels.CompletionHandler}) * except that multiple &lt;em&gt;pending&lt;/em&gt; completions may be necessary * to trigger the completion action {@link #onCompletion(CountedCompleter)}, * not just one." />
      <item value="A {@link ForkJoinTask} with a completion action performed when * triggered and there are no remaining pending actions. * CountedCompleters are in general more robust in the * presence of subtask stalls and blockage than are other forms of * ForkJoinTasks, but are less intuitive to program" />
      <item value="robust" />
      <item value="Insertion into a CLH queue requires only a single atomic * operation on &quot;tail&quot;, so there is a simple atomic point of * demarcation from unqueued to queued. Similarly, dequeuing * involves only updating the &quot;head&quot;. However, it takes a bit * more work for nodes to determine who their successors are, * in part to deal with possible cancellation due to timeouts * and interrupts." />
      <item value="tactic" />
      <item value="A thread may try to acquire if it is * first in the queue. But being first does not guarantee success; * it only gives the right to contend. So the currently released * contender thread may need to rewait." />
      <item value="CLH locks are normally used for * spinlocks." />
      <item value="Craig" />
      <item value="The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and * Hagersten) lock queue." />
      <item value="Abstract Queued Synchronizer" />
      <item value="Instead it defines methods such as * {@link #acquireInterruptibly} that can be invoked as * appropriate by concrete locks and related synchronizers to * implement their public methods." />
      <item value="Class * {@code AbstractQueuedSynchronizer} does not implement any * synchronization interface." />
      <item value="&gt;Subclasses should be defined as non-public internal helper * classes that are used to implement the synchronization properties * of their enclosing class." />
      <item value="Provides a framework for implementing blocking locks and related * synchronizers (semaphores, events, etc) that rely on * first-in-first-out (FIFO) wait queues. This class is designed to * be a useful basis for most kinds of synchronizers that rely on a * single atomic {@code int} value to represent state. Subclasses * must define the protected methods that change this state, and which * define what that state means in terms of this object being acquired * or released. Given these, the other methods in this class carry * out all queuing and blocking mechanics. Subclasses can maintain * other state fields, but only the atomically updated {@code int} * value manipulated using methods {@link #getState}, {@link * #setState} and {@link #compareAndSetState} is tracked with respect * to synchronization." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="700" />
        <entry key="ENGLISH" value="770" />
        <entry key="FRENCH" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="phoneticFontFamily" value="Meiryo UI" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="translator" value="ai.youdao" />
    <option name="ttsSource" value="TRANSLATION" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>
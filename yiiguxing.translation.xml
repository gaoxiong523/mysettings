<application>
  <component name="AppStorage">
    <histories>
      <item value="A {@link HttpSecurity} is similar to Spring Security's XML &amp;lt;http&amp;gt; element in the * namespace configuration. It allows configuring web based security for specific http * requests. By default it will be applied to all requests, but can be restricted using * {@link #requestMatcher(RequestMatcher)} or other similar methods." />
      <item value="An OAuth2 client filter that can be used to acquire an OAuth2 access token from an authorization server, and load an * authentication object into the SecurityContext" />
      <item value="Allows subclasses to actually retrieve the &lt;code&gt;UserDetails&lt;/code&gt; from an * implementation-specific location, with the option of throwing an * &lt;code&gt;AuthenticationException&lt;/code&gt; immediately if the presented credentials are * incorrect (this is especially useful if it is necessary to bind to a resource as * the user in order to obtain or generate a &lt;code&gt;UserDetails&lt;/code&gt;). * &lt;p&gt; * Subclasses are not required to perform any caching, as the * &lt;code&gt;AbstractUserDetailsAuthenticationProvider&lt;/code&gt; will by default cache the * &lt;code&gt;UserDetails&lt;/code&gt;. The caching of &lt;code&gt;UserDetails&lt;/code&gt; does present * additional complexity as this means subsequent requests that rely on the cache will * need to still have their credentials validated, even if the correctness of * credentials was assured by subclasses adopting a binding-based strategy in this * method. Accordingly it is important that subclasses either disable caching (if they * want to ensure that this method is the only method that is capable of * authenticating a request, as no &lt;code&gt;UserDetails&lt;/code&gt; will ever be cached) or * ensure subclasses implement * {@link #additionalAuthenticationChecks(UserDetails, UsernamePasswordAuthenticationToken)} * to compare the credentials of a cached &lt;code&gt;UserDetails&lt;/code&gt; with subsequent * authentication requests. * &lt;/p&gt; * &lt;p&gt; * Most of the time subclasses will not perform credentials inspection in this method, * instead performing it in * {@link #additionalAuthenticationChecks(UserDetails, UsernamePasswordAuthenticationToken)} * so that code related to credentials validation need not be duplicated across two * methods. * &lt;/p&gt; * * @param username The username to retrieve * @param authentication The authentication request, which subclasses &lt;em&gt;may&lt;/em&gt; * need to perform a binding-based retrieval of the &lt;code&gt;UserDetails&lt;/code&gt; * * @return the user information (never &lt;code&gt;null&lt;/code&gt; - instead an exception should * the thrown) * * @throws AuthenticationException if the credentials could not be validated * (generally a &lt;code&gt;BadCredentialsException&lt;/code&gt;, an * &lt;code&gt;AuthenticationServiceException&lt;/code&gt; or * &lt;code&gt;UsernameNotFoundException&lt;/code&gt;)" />
      <item value="Ensure we return the original credentials the user supplied, // so subsequent attempts are successful even with encoded passwords. // Also ensure we return the original getDetails(), so that future // authentication events after cache expiry contain the details" />
      <item value="Allows subclasses to perform any additional checks of a returned (or cached) * &lt;code&gt;UserDetails&lt;/code&gt; for a given authentication request. Generally a subclass * will at least compare the {@link Authentication#getCredentials()} with a * {@link UserDetails#getPassword()}. If custom logic is needed to compare additional * properties of &lt;code&gt;UserDetails&lt;/code&gt; and/or * &lt;code&gt;UsernamePasswordAuthenticationToken&lt;/code&gt;, these should also appear in this * method." />
      <item value="Caching is handled by storing the &lt;code&gt;UserDetails&lt;/code&gt; object being placed in the * {@link UserCache}. This ensures that subsequent requests with the same username can be * validated without needing to query the {@link UserDetailsService}. It should be noted * that if a user appears to present an incorrect password, the {@link UserDetailsService} * will be queried to confirm the most up-to-date password was used for comparison. * Caching is only likely to be required for stateless applications. In a normal web * application, for example, the &lt;tt&gt;SecurityContext&lt;/tt&gt; is stored in the user's session * and the user isn't reauthenticated on each request. The default cache implementation is * therefore {@link NullUserCache}." />
      <item value="As container adapters are not recommended to be used, and * &lt;code&gt;UserDetails&lt;/code&gt; implementations provide additional flexibility, by default a * &lt;code&gt;UserDetails&lt;/code&gt; is returned. To override this default, set the * {@link #setForcePrincipalAsString} to &lt;code&gt;true&lt;/code&gt;." />
      <item value="Using &lt;code&gt;UserDetails&lt;/code&gt; is appropriate if you require access to * additional properties of the authenticated user, such as email addresses, * human-friendly names etc." />
      <item value="Using &lt;code&gt;String&lt;/code&gt; is appropriate * if a container adapter is being used, as it expects &lt;code&gt;String&lt;/code&gt; representations * of the username" />
      <item value="Upon successful validation, a &lt;code&gt;UsernamePasswordAuthenticationToken&lt;/code&gt; will be * created and returned to the caller. The token will include as its principal either a * &lt;code&gt;String&lt;/code&gt; representation of the username, or the {@link UserDetails} that was * returned from the authentication repository" />
      <item value="subclasses" />
      <item value="A base {@link AuthenticationProvider} that allows subclasses to override and work with * {@link org.springframework.security.core.userdetails.UserDetails} objects. The class is * designed to respond to {@link UsernamePasswordAuthenticationToken} authentication * requests." />
      <item value="Sets a new list of custom authentication filters for the TokenEndpoint. Filters will be set upstream of the * default BasicAuthenticationFilter." />
      <item value="Adds a new custom authentication filter for the TokenEndpoint. Filters will be set upstream of the default * BasicAuthenticationFilter." />
      <item value="token Key Access" />
      <item value="check Token Access" />
      <item value="An unordered, unkeyed collection that can contain the same element * multiple times. The Java collections API, curiously, has no &lt;tt&gt;Bag&lt;/tt&gt;. * Most developers seem to use &lt;tt&gt;List&lt;/tt&gt;s to represent bag semantics, * so Hibernate follows this practice." />
      <item value="All the implementations supplied by the static methods are immutable." />
      <item value="This class contains a standard set of adjusters, available as static methods." />
      <item value="It is recommended to use the second approach, {@code with(TemporalAdjuster)}, * as it is a lot clearer to read in code." />
      <item value="There are two equivalent ways of using a {@code TemporalAdjuster}. * The first is to invoke the method on the interface directly. * The second is to use {@link Temporal#with(TemporalAdjuster)}:" />
      <item value="Adjusters are a key tool for modifying temporal objects. * They exist to externalize the process of adjustment, permitting different * approaches, as per the strategy design pattern. * Examples might be an adjuster that sets the date avoiding weekends, or one that * sets the date to the last day of the month." />
      <item value="Common and useful TemporalAdjusters." />
      <item value="Temporal Adjusters" />
      <item value="Temporal Adjuster" />
      <item value="ability" />
      <item value="Total rate for all RateLimiter instances working with the same Redisson instance" />
      <item value="Total rate for all RateLimiter instances" />
      <item value="Redisson Transactional Lock" />
      <item value="geospatial" />
      <item value="binary" />
      <item value="Returns rate limiter instance by &lt;code&gt;name&lt;/code&gt;" />
      <item value="Main Redisson interface for access * to all redisson objects with sync/async interface." />
      <item value="Override this method to configure the {@link HttpSecurity}. Typically subclasses * should not invoke this method by calling super as it may override their * configuration. The default configuration is:" />
      <item value="Configure the properties and enhanced functionality of the Authorization Server endpoints." />
      <item value="Zero or more {@code RequestInterceptors} may be configured for purposes such as adding headers to * all requests. No guarantees are give with regards to the order that interceptors are applied. * Once interceptors are applied, {@link Target#apply(RequestTemplate)} is called to create the * immutable http request sent via {@link Client#execute(Request, feign.Request.Options)}. &lt;br&gt;" />
      <item value="An {@code int} value that may be updated atomically. See the * {@link java.util.concurrent.atomic} package specification for * description of the properties of atomic variables. An * {@code AtomicInteger} is used in applications such as atomically * incremented counters, and cannot be used as a replacement for an * {@link java.lang.Integer}. However, this class does extend * {@code Number} to allow uniform access by tools and utilities that * deal with numerically-based classes." />
      <item value="Memory consistency effects: For each pair of threads that * successfully exchange objects via an {@code Exchanger}, actions * prior to the {@code exchange()} in each thread * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt; * those subsequent to a return from the corresponding {@code exchange()} * in the other thread." />
      <item value="Here are the highlights of a class that uses an {@code Exchanger} * to swap buffers between threads so that the thread filling the * buffer gets a freshly emptied one when it needs it, handing off the * filled one to the thread emptying the buffer." />
      <item value="A synchronization point at which threads can pair and swap elements * within pairs. Each thread presents some object on entry to the * {@link #exchange exchange} method, matches with a partner thread, * and receives its partner's object on return. An Exchanger may be * viewed as a bidirectional form of a {@link SynchronousQueue}. * Exchangers may be useful in applications such as genetic algorithms * and pipeline designs." />
      <item value="additional Authentication Checks" />
      <item value="Protect from downstream leaks of password" />
      <item value="A pre-authentication filter for OAuth2 protected resources. Extracts an OAuth2 token from the incoming request and * uses it to populate the Spring Security context with an {@link OAuth2Authentication} (if used in conjunction with an * {@link OAuth2AuthenticationManager})." />
      <item value="conjunction" />
      <item value="set Serialization Strategy" />
      <item value="Lettuce Connection Factory" />
      <item value="持久化" />
      <item value="The class is * designed to respond to {@link UsernamePasswordAuthenticationToken} authentication * requests." />
      <item value="An {@link AuthenticationProvider} implementation that retrieves user details from a * {@link UserDetailsService}." />
      <item value="Retrieve" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="399" />
        <entry key="ENGLISH" value="450" />
        <entry key="FRENCH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="047c5f8aedf1f7ca" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>